-----------------------------------------------------------------
-- Autogenerated by Thrift
--
-- DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
--  @generated
-----------------------------------------------------------------
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE BangPatterns #-}
{-# OPTIONS_GHC -fno-warn-unused-imports#-}
{-# OPTIONS_GHC -fno-warn-overlapping-patterns#-}
{-# OPTIONS_GHC -fno-warn-incomplete-patterns#-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
module B.Types
       (B(B, b_a, b_b, b_c), C(C, c_x, c_y, c_z),
        Number(Number_Zero, Number_One, Number_Two, Number_Three,
               Number__UNKNOWN),
        Number_Strict(Number_Strict_Zero),
        Number_Discontinuous(Number_Discontinuous_Five,
                             Number_Discontinuous_Zero, Number_Discontinuous__UNKNOWN),
        Number_Empty(Number_Empty__UNKNOWN), Int(Int, unInt), byte_value,
        i16_value, i32_value, i64_value, float_value, double_value,
        bool_value, string_value, binary_value, newtype_value, list_value,
        set_value, map_value, hash_map_value, struct_value,
        explicit_struct_value, explicit_nested_struct_value)
       where
import qualified Control.DeepSeq as DeepSeq
import qualified Control.Exception as Exception
import qualified Control.Monad as Monad
import qualified Control.Monad.ST.Trans as ST
import qualified Control.Monad.Trans.Class as Trans
import qualified Data.Aeson as Aeson
import qualified Data.Aeson.Types as Aeson
import qualified Data.ByteString as ByteString
import qualified Data.Default as Default
import qualified Data.Function as Function
import qualified Data.HashMap.Strict as HashMap
import qualified Data.Hashable as Hashable
import qualified Data.Int as Int
import qualified Data.List as List
import qualified Data.Map.Strict as Map
import qualified Data.Ord as Ord
import qualified Data.Set as Set
import qualified Data.Text as Text
import qualified Data.Text.Encoding as Text
import qualified Prelude as Prelude
import qualified Thrift.Binary.Parser as Parser
import qualified Thrift.CodegenTypesOnly as Thrift
import Control.Applicative ((<|>), (*>), (<*))
import Data.Aeson ((.:), (.:?), (.=), (.!=))
import Data.Monoid ((<>))
import Prelude ((.), (++), (>), (==))
import Prelude ((.), (<$>), (<*>), (>>=), (==), (/=), (<), (++))

data B = B{b_a :: Int.Int16, b_b :: Int.Int32, b_c :: Int.Int64}
         deriving (Prelude.Eq, Prelude.Show, Prelude.Ord)

instance Aeson.ToJSON B where
  toJSON (B __field__a __field__b __field__c)
    = Aeson.object
        ("a" .= __field__a :
           "b" .= __field__b : "c" .= __field__c : Prelude.mempty)

instance Thrift.ThriftStruct B where
  buildStruct _proxy (B __field__a __field__b __field__c)
    = Thrift.genStruct _proxy
        (Thrift.genFieldPrim _proxy "a" (Thrift.getI16Type _proxy) 1 0
           (Thrift.genI16Prim _proxy)
           __field__a
           :
           Thrift.genFieldPrim _proxy "b" (Thrift.getI32Type _proxy) 2 1
             (Thrift.genI32Prim _proxy)
             __field__b
             :
             Thrift.genFieldPrim _proxy "c" (Thrift.getI64Type _proxy) 3 2
               (Thrift.genI64Prim _proxy)
               __field__c
               : [])
  parseStruct _proxy
    = ST.runSTT
        (do Prelude.return ()
            __field__a <- ST.newSTRef 1
            __field__b <- ST.newSTRef Default.def
            __field__c <- ST.newSTRef Default.def
            let
              _parse _lastId
                = do _fieldBegin <- Trans.lift
                                      (Thrift.parseFieldBegin _proxy _lastId _idMap)
                     case _fieldBegin of
                       Thrift.FieldBegin _type _id _bool -> do case _id of
                                                                 1 | _type ==
                                                                       Thrift.getI16Type _proxy
                                                                     ->
                                                                     do !_val <- Trans.lift
                                                                                   (Thrift.parseI16
                                                                                      _proxy)
                                                                        ST.writeSTRef __field__a
                                                                          _val
                                                                 2 | _type ==
                                                                       Thrift.getI32Type _proxy
                                                                     ->
                                                                     do !_val <- Trans.lift
                                                                                   (Thrift.parseI32
                                                                                      _proxy)
                                                                        ST.writeSTRef __field__b
                                                                          _val
                                                                 3 | _type ==
                                                                       Thrift.getI64Type _proxy
                                                                     ->
                                                                     do !_val <- Trans.lift
                                                                                   (Thrift.parseI64
                                                                                      _proxy)
                                                                        ST.writeSTRef __field__c
                                                                          _val
                                                                 _ -> Trans.lift
                                                                        (Thrift.parseSkip _proxy
                                                                           _type
                                                                           (Prelude.Just _bool))
                                                               _parse _id
                       Thrift.FieldEnd -> do !__val__a <- ST.readSTRef __field__a
                                             !__val__b <- ST.readSTRef __field__b
                                             !__val__c <- ST.readSTRef __field__c
                                             Prelude.pure (B __val__a __val__b __val__c)
              _idMap = HashMap.fromList [("a", 1), ("b", 2), ("c", 3)]
            _parse 0)

instance DeepSeq.NFData B where
  rnf (B __field__a __field__b __field__c)
    = DeepSeq.rnf __field__a `Prelude.seq`
        DeepSeq.rnf __field__b `Prelude.seq`
          DeepSeq.rnf __field__c `Prelude.seq` ()

instance Default.Default B where
  def = B 1 Default.def Default.def

instance Hashable.Hashable B where
  hashWithSalt __salt (B _a _b _c)
    = Hashable.hashWithSalt
        (Hashable.hashWithSalt (Hashable.hashWithSalt __salt _a) _b)
        _c

data C = C{c_x :: [Number], c_y :: [Number_Strict], c_z :: B}
         deriving (Prelude.Eq, Prelude.Show, Prelude.Ord)

instance Aeson.ToJSON C where
  toJSON (C __field__x __field__y __field__z)
    = Aeson.object
        ("x" .= __field__x :
           "y" .= __field__y : "z" .= __field__z : Prelude.mempty)

instance Thrift.ThriftStruct C where
  buildStruct _proxy (C __field__x __field__y __field__z)
    = Thrift.genStruct _proxy
        (Thrift.genField _proxy "x" (Thrift.getListType _proxy) 1 0
           (Thrift.genList _proxy (Thrift.getI32Type _proxy)
              (Thrift.genI32 _proxy . Prelude.fromIntegral .
                 Thrift.fromThriftEnum)
              __field__x)
           :
           Thrift.genField _proxy "y" (Thrift.getListType _proxy) 2 1
             (Thrift.genList _proxy (Thrift.getI32Type _proxy)
                (Thrift.genI32 _proxy . Prelude.fromIntegral .
                   Thrift.fromThriftEnum)
                __field__y)
             :
             Thrift.genField _proxy "z" (Thrift.getStructType _proxy) 3 2
               (Thrift.buildStruct _proxy __field__z)
               : [])
  parseStruct _proxy
    = ST.runSTT
        (do Prelude.return ()
            __field__x <- ST.newSTRef Default.def
            __field__y <- ST.newSTRef Default.def
            __field__z <- ST.newSTRef Default.def
            let
              _parse _lastId
                = do _fieldBegin <- Trans.lift
                                      (Thrift.parseFieldBegin _proxy _lastId _idMap)
                     case _fieldBegin of
                       Thrift.FieldBegin _type _id _bool -> do case _id of
                                                                 1 | _type ==
                                                                       Thrift.getListType _proxy
                                                                     ->
                                                                     do !_val <- Trans.lift
                                                                                   (Prelude.snd <$>
                                                                                      Thrift.parseList
                                                                                        _proxy
                                                                                        (Thrift.parseEnum
                                                                                           _proxy
                                                                                           "Number"))
                                                                        ST.writeSTRef __field__x
                                                                          _val
                                                                 2 | _type ==
                                                                       Thrift.getListType _proxy
                                                                     ->
                                                                     do !_val <- Trans.lift
                                                                                   (Prelude.snd <$>
                                                                                      Thrift.parseList
                                                                                        _proxy
                                                                                        (Thrift.parseEnumNoUnknown
                                                                                           _proxy
                                                                                           "Number_Strict"))
                                                                        ST.writeSTRef __field__y
                                                                          _val
                                                                 3 | _type ==
                                                                       Thrift.getStructType _proxy
                                                                     ->
                                                                     do !_val <- Trans.lift
                                                                                   (Thrift.parseStruct
                                                                                      _proxy)
                                                                        ST.writeSTRef __field__z
                                                                          _val
                                                                 _ -> Trans.lift
                                                                        (Thrift.parseSkip _proxy
                                                                           _type
                                                                           (Prelude.Just _bool))
                                                               _parse _id
                       Thrift.FieldEnd -> do !__val__x <- ST.readSTRef __field__x
                                             !__val__y <- ST.readSTRef __field__y
                                             !__val__z <- ST.readSTRef __field__z
                                             Prelude.pure (C __val__x __val__y __val__z)
              _idMap = HashMap.fromList [("x", 1), ("y", 2), ("z", 3)]
            _parse 0)

instance DeepSeq.NFData C where
  rnf (C __field__x __field__y __field__z)
    = DeepSeq.rnf __field__x `Prelude.seq`
        DeepSeq.rnf __field__y `Prelude.seq`
          DeepSeq.rnf __field__z `Prelude.seq` ()

instance Default.Default C where
  def = C Default.def Default.def Default.def

instance Hashable.Hashable C where
  hashWithSalt __salt (C _x _y _z)
    = Hashable.hashWithSalt
        (Hashable.hashWithSalt (Hashable.hashWithSalt __salt _x) _y)
        _z

data Number = Number_Zero
            | Number_One
            | Number_Two
            | Number_Three
            | Number__UNKNOWN Prelude.Int
              deriving (Prelude.Eq, Prelude.Show, Prelude.Ord)

instance Aeson.ToJSON Number where
  toJSON = Aeson.toJSON . Thrift.fromThriftEnum

instance DeepSeq.NFData Number where
  rnf __Number = Prelude.seq __Number ()

instance Default.Default Number where
  def = Number_Zero

instance Hashable.Hashable Number where
  hashWithSalt _salt _val
    = Hashable.hashWithSalt _salt (Thrift.fromThriftEnum _val)

instance Thrift.ThriftEnum Number where
  toThriftEnum 0 = Number_Zero
  toThriftEnum 1 = Number_One
  toThriftEnum 2 = Number_Two
  toThriftEnum 3 = Number_Three
  toThriftEnum val = Number__UNKNOWN val
  fromThriftEnum Number_Zero = 0
  fromThriftEnum Number_One = 1
  fromThriftEnum Number_Two = 2
  fromThriftEnum Number_Three = 3
  fromThriftEnum (Number__UNKNOWN val) = val
  allThriftEnumValues
    = [Number_Zero, Number_One, Number_Two, Number_Three]
  toThriftEnumEither 0 = Prelude.Right Number_Zero
  toThriftEnumEither 1 = Prelude.Right Number_One
  toThriftEnumEither 2 = Prelude.Right Number_Two
  toThriftEnumEither 3 = Prelude.Right Number_Three
  toThriftEnumEither val
    = Prelude.Left
        ("toThriftEnumEither: not a valid identifier for enum Number: " ++
           Prelude.show val)

data Number_Strict = Number_Strict_Zero
                     deriving (Prelude.Eq, Prelude.Show, Prelude.Ord)

instance Aeson.ToJSON Number_Strict where
  toJSON = Aeson.toJSON . Thrift.fromThriftEnum

instance DeepSeq.NFData Number_Strict where
  rnf __Number_Strict = Prelude.seq __Number_Strict ()

instance Default.Default Number_Strict where
  def = Number_Strict_Zero

instance Hashable.Hashable Number_Strict where
  hashWithSalt _salt _val
    = Hashable.hashWithSalt _salt (Thrift.fromThriftEnum _val)

instance Thrift.ThriftEnum Number_Strict where
  toThriftEnum 0 = Number_Strict_Zero
  toThriftEnum _val
    = Exception.throw
        (Thrift.ProtocolException
           ("toThriftEnum: not a valid identifier for enum Number_Strict: " ++
              Prelude.show _val))
  fromThriftEnum Number_Strict_Zero = 0
  fromThriftEnum _val
    = Exception.throw
        (Thrift.ProtocolException
           ("fromThriftEnum: not a valid identifier for enum Number_Strict: "
              ++ Prelude.show _val))
  allThriftEnumValues = [Number_Strict_Zero]
  toThriftEnumEither 0 = Prelude.Right Number_Strict_Zero
  toThriftEnumEither val
    = Prelude.Left
        ("toThriftEnumEither: not a valid identifier for enum Number_Strict: "
           ++ Prelude.show val)

data Number_Discontinuous = Number_Discontinuous_Zero
                          | Number_Discontinuous_Five
                          | Number_Discontinuous__UNKNOWN Prelude.Int
                            deriving (Prelude.Eq, Prelude.Show)

instance Aeson.ToJSON Number_Discontinuous where
  toJSON = Aeson.toJSON . Thrift.fromThriftEnum

instance DeepSeq.NFData Number_Discontinuous where
  rnf __Number_Discontinuous = Prelude.seq __Number_Discontinuous ()

instance Default.Default Number_Discontinuous where
  def = Number_Discontinuous_Five

instance Hashable.Hashable Number_Discontinuous where
  hashWithSalt _salt _val
    = Hashable.hashWithSalt _salt (Thrift.fromThriftEnum _val)

instance Thrift.ThriftEnum Number_Discontinuous where
  toThriftEnum 5 = Number_Discontinuous_Five
  toThriftEnum 0 = Number_Discontinuous_Zero
  toThriftEnum val = Number_Discontinuous__UNKNOWN val
  fromThriftEnum Number_Discontinuous_Five = 5
  fromThriftEnum Number_Discontinuous_Zero = 0
  fromThriftEnum (Number_Discontinuous__UNKNOWN val) = val
  allThriftEnumValues
    = [Number_Discontinuous_Zero, Number_Discontinuous_Five]
  toThriftEnumEither 5 = Prelude.Right Number_Discontinuous_Five
  toThriftEnumEither 0 = Prelude.Right Number_Discontinuous_Zero
  toThriftEnumEither val
    = Prelude.Left
        ("toThriftEnumEither: not a valid identifier for enum Number_Discontinuous: "
           ++ Prelude.show val)

instance Prelude.Ord Number_Discontinuous where
  compare = Function.on Prelude.compare Thrift.fromThriftEnum

data Number_Empty = Number_Empty__UNKNOWN Prelude.Int

instance Prelude.Eq Number_Empty where
  (==)
    = Exception.throw
        (Thrift.ProtocolException
           "(==): Thrift enum 'Number_Empty' is uninhabited")

instance Prelude.Show Number_Empty where
  show
    = Exception.throw
        (Thrift.ProtocolException
           "show: Thrift enum 'Number_Empty' is uninhabited")

instance Prelude.Ord Number_Empty where
  compare
    = Exception.throw
        (Thrift.ProtocolException
           "compare: Thrift enum 'Number_Empty' is uninhabited")

instance Aeson.ToJSON Number_Empty where
  toJSON
    = Exception.throw
        (Thrift.ProtocolException
           "toJSON: Thrift enum 'Number_Empty' is uninhabited")

instance Default.Default Number_Empty where
  def
    = Exception.throw
        (Thrift.ProtocolException
           "def: Thrift enum 'Number_Empty' is uninhabited")

instance Hashable.Hashable Number_Empty where
  hashWithSalt
    = Exception.throw
        (Thrift.ProtocolException
           "hashWithSalt: Thrift enum 'Number_Empty' is uninhabited")

instance DeepSeq.NFData Number_Empty where
  rnf
    = Exception.throw
        (Thrift.ProtocolException
           "rnf: Thrift enum 'Number_Empty' is uninhabited")

instance Thrift.ThriftEnum Number_Empty where
  toThriftEnum
    = Exception.throw
        (Thrift.ProtocolException
           "toThriftEnum: Thrift enum 'Number_Empty' is uninhabited")
  fromThriftEnum
    = Exception.throw
        (Thrift.ProtocolException
           "fromThriftEnum: Thrift enum 'Number_Empty' is uninhabited")
  allThriftEnumValues
    = Exception.throw
        (Thrift.ProtocolException
           "allThriftEnumValues: Thrift enum 'Number_Empty' is uninhabited")
  toThriftEnumEither
    = Exception.throw
        (Thrift.ProtocolException
           "toThriftEnumEither: Thrift enum 'Number_Empty' is uninhabited")

newtype Int = Int{unInt :: Int.Int64}
              deriving (Prelude.Eq, Prelude.Show, DeepSeq.NFData, Prelude.Ord)

instance Hashable.Hashable Int where
  hashWithSalt __salt (Int __val)
    = Hashable.hashWithSalt __salt __val

instance Aeson.ToJSON Int where
  toJSON (Int __val) = Aeson.toJSON __val

byte_value :: Int.Int8
byte_value = 0

i16_value :: Int.Int16
i16_value = 1

i32_value :: Int.Int32
i32_value = 2

i64_value :: Int.Int64
i64_value = 3

float_value :: Prelude.Float
float_value = 0.5

double_value :: Prelude.Double
double_value = 3.14159

bool_value :: Prelude.Bool
bool_value = Prelude.True

string_value :: Text.Text
string_value = "xxx"

binary_value :: ByteString.ByteString
binary_value = "yyy"

newtype_value :: Int
newtype_value = Int 10

list_value :: [Int.Int64]
list_value = [0, i64_value]

set_value :: Set.Set Text.Text
set_value = Set.fromList [string_value, ""]

map_value :: Map.Map Int.Int64 Prelude.Bool
map_value = Map.fromList [(0, Prelude.True), (1, Prelude.False)]

hash_map_value :: HashMap.HashMap Text.Text Text.Text
hash_map_value = HashMap.fromList [("a", "A"), ("b", "B")]

struct_value :: B
struct_value = (Default.def :: B){b_a = 1, b_b = 2, b_c = 3}

explicit_struct_value :: B
explicit_struct_value
  = (Default.def :: B){b_a = 1, b_b = 2, b_c = 3}

explicit_nested_struct_value :: C
explicit_nested_struct_value
  = (Default.def :: C){c_x = [], c_y = [],
                       c_z = (Default.def :: B){b_a = 1, b_b = 2, b_c = 3}}