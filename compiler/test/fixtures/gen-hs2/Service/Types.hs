-----------------------------------------------------------------
-- Autogenerated by Thrift
--
-- DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
--  @generated
-----------------------------------------------------------------
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE BangPatterns #-}
{-# OPTIONS_GHC -fno-warn-unused-imports#-}
{-# OPTIONS_GHC -fno-warn-overlapping-patterns#-}
{-# OPTIONS_GHC -fno-warn-incomplete-patterns#-}
{-# OPTIONS_GHC -fno-warn-incomplete-uni-patterns#-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE DataKinds #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE MultiParamTypeClasses #-}
module Service.Types (Z(Z, z_name), z, TestFunc(TestFunc), Ex(Ex))
       where
import qualified Control.DeepSeq as DeepSeq
import qualified Control.Exception as Exception
import qualified Control.Monad as Monad
import qualified Control.Monad.ST.Trans as ST
import qualified Control.Monad.Trans.Class as Trans
import qualified Data.Aeson as Aeson
import qualified Data.Aeson.Types as Aeson
import qualified Data.Default as Default
import qualified Data.HashMap.Strict as HashMap
import qualified Data.Hashable as Hashable
import qualified Data.List as List
import qualified Data.Ord as Ord
import qualified Data.Text as Text
import qualified Data.Text.Encoding as Text
import qualified Prelude as Prelude
import qualified Thrift.Binary.Parser as Parser
import qualified Thrift.CodegenTypesOnly as Thrift
import Control.Applicative ((<|>), (*>), (<*))
import Data.Aeson ((.:), (.:?), (.=), (.!=))
import Data.Monoid ((<>))
import Prelude ((.), (<$>), (<*>), (>>=), (==), (/=), (<), (++))

newtype Z = Z{z_name :: Text.Text}
            deriving (Prelude.Eq, Prelude.Show, Prelude.Ord)

instance Aeson.ToJSON Z where
  toJSON (Z __field__name)
    = Aeson.object ("name" .= __field__name : Prelude.mempty)

instance Thrift.ThriftStruct Z where
  buildStruct _proxy (Z __field__name)
    = Thrift.genStruct _proxy
        (Thrift.genField _proxy "name" (Thrift.getStringType _proxy) 1 0
           (Thrift.genText _proxy __field__name)
           : [])
  parseStruct _proxy
    = ST.runSTT
        (do Prelude.return ()
            __field__name <- ST.newSTRef ""
            let
              _parse _lastId
                = do _fieldBegin <- Trans.lift
                                      (Thrift.parseFieldBegin _proxy _lastId _idMap)
                     case _fieldBegin of
                       Thrift.FieldBegin _type _id _bool -> do case _id of
                                                                 1 | _type ==
                                                                       Thrift.getStringType _proxy
                                                                     ->
                                                                     do !_val <- Trans.lift
                                                                                   (Thrift.parseText
                                                                                      _proxy)
                                                                        ST.writeSTRef __field__name
                                                                          _val
                                                                 _ -> Trans.lift
                                                                        (Thrift.parseSkip _proxy
                                                                           _type
                                                                           (Prelude.Just _bool))
                                                               _parse _id
                       Thrift.FieldEnd -> do !__val__name <- ST.readSTRef __field__name
                                             Prelude.pure (Z __val__name)
              _idMap = HashMap.fromList [("name", 1)]
            _parse 0)

instance DeepSeq.NFData Z where
  rnf (Z __field__name) = DeepSeq.rnf __field__name `Prelude.seq` ()

instance Default.Default Z where
  def = Z ""

instance Hashable.Hashable Z where
  hashWithSalt __salt (Z _name) = Hashable.hashWithSalt __salt _name

instance Thrift.HasField "name" Z (Text.Text) where
  getField = z_name

z :: Z
z = (Default.def :: Z){z_name = "Z"}

data TestFunc = TestFunc{}
                deriving (Prelude.Eq, Prelude.Show, Prelude.Ord)

instance Aeson.ToJSON TestFunc where
  toJSON TestFunc = Aeson.object Prelude.mempty

instance Thrift.ThriftStruct TestFunc where
  buildStruct _proxy TestFunc = Thrift.genStruct _proxy []
  parseStruct _proxy
    = ST.runSTT
        (do Prelude.return ()
            let
              _parse _lastId
                = do _fieldBegin <- Trans.lift
                                      (Thrift.parseFieldBegin _proxy _lastId _idMap)
                     case _fieldBegin of
                       Thrift.FieldBegin _type _id _bool -> do case _id of
                                                                 _ -> Trans.lift
                                                                        (Thrift.parseSkip _proxy
                                                                           _type
                                                                           (Prelude.Just _bool))
                                                               _parse _id
                       Thrift.FieldEnd -> do Prelude.pure (TestFunc)
              _idMap = HashMap.fromList []
            _parse 0)

instance DeepSeq.NFData TestFunc where
  rnf TestFunc = ()

instance Default.Default TestFunc where
  def = TestFunc

instance Hashable.Hashable TestFunc where
  hashWithSalt __salt TestFunc = __salt

data Ex = Ex{}
          deriving (Prelude.Eq, Prelude.Show, Prelude.Ord)

instance Aeson.ToJSON Ex where
  toJSON Ex = Aeson.object Prelude.mempty

instance Thrift.ThriftStruct Ex where
  buildStruct _proxy Ex = Thrift.genStruct _proxy []
  parseStruct _proxy
    = ST.runSTT
        (do Prelude.return ()
            let
              _parse _lastId
                = do _fieldBegin <- Trans.lift
                                      (Thrift.parseFieldBegin _proxy _lastId _idMap)
                     case _fieldBegin of
                       Thrift.FieldBegin _type _id _bool -> do case _id of
                                                                 _ -> Trans.lift
                                                                        (Thrift.parseSkip _proxy
                                                                           _type
                                                                           (Prelude.Just _bool))
                                                               _parse _id
                       Thrift.FieldEnd -> do Prelude.pure (Ex)
              _idMap = HashMap.fromList []
            _parse 0)

instance DeepSeq.NFData Ex where
  rnf Ex = ()

instance Default.Default Ex where
  def = Ex

instance Hashable.Hashable Ex where
  hashWithSalt __salt Ex = __salt

instance Exception.Exception Ex