-----------------------------------------------------------------
-- Autogenerated by Thrift
--
-- DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
--  @generated
-----------------------------------------------------------------
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE BangPatterns #-}
{-# OPTIONS_GHC -fno-warn-unused-imports#-}
{-# OPTIONS_GHC -fno-warn-overlapping-patterns#-}
{-# OPTIONS_GHC -fno-warn-incomplete-patterns#-}
{-# OPTIONS_GHC -fno-warn-incomplete-uni-patterns#-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE DataKinds #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE MultiParamTypeClasses #-}
module Thrift.Types
       (Experimental(Experimental),
        ReserveIds(ReserveIds, reserveIds_ids, reserveIds_id_ranges),
        RequiresBackwardCompatibility(RequiresBackwardCompatibility,
                                      requiresBackwardCompatibility_field_name),
        TerseWrite(TerseWrite), Box(Box), Mixin(Mixin),
        SerializeInFieldIdOrder(SerializeInFieldIdOrder),
        BitmaskEnum(BitmaskEnum), ExceptionMessage(ExceptionMessage),
        GenerateRuntimeSchema(GenerateRuntimeSchema,
                              generateRuntimeSchema_name),
        InternBox(InternBox), Serial(Serial), Uri(Uri, uri_value),
        Priority(Priority, priority_level),
        RpcPriority(RpcPriority_HIGH_IMPORTANT, RpcPriority_HIGH,
                    RpcPriority_IMPORTANT, RpcPriority_NORMAL, RpcPriority_BEST_EFFORT,
                    RpcPriority__UNKNOWN),
        DeprecatedUnvalidatedAnnotations(DeprecatedUnvalidatedAnnotations,
                                         deprecatedUnvalidatedAnnotations_items))
       where
import qualified Control.DeepSeq as DeepSeq
import qualified Control.Exception as Exception
import qualified Control.Monad as Monad
import qualified Control.Monad.ST.Trans as ST
import qualified Control.Monad.Trans.Class as Trans
import qualified Data.Aeson as Aeson
import qualified Data.Aeson.Types as Aeson
import qualified Data.Default as Default
import qualified Data.Function as Function
import qualified Data.HashMap.Strict as HashMap
import qualified Data.Hashable as Hashable
import qualified Data.Int as Int
import qualified Data.List as List
import qualified Data.Map.Strict as Map
import qualified Data.Ord as Ord
import qualified Data.Text as Text
import qualified Data.Text.Encoding as Text
import qualified GHC.Magic as GHC
import qualified Prelude as Prelude
import qualified Scope.Types as Scope
import qualified Thrift.Binary.Parser as Parser
import qualified Thrift.CodegenTypesOnly as Thrift
import Control.Applicative ((<|>), (*>), (<*))
import Data.Aeson ((.:), (.:?), (.=), (.!=))
import Data.Monoid ((<>))
import Prelude ((.), (++), (>), (==))
import Prelude ((.), (<$>), (<*>), (>>=), (==), (/=), (<), (++))

data Experimental = Experimental{}
                    deriving (Prelude.Eq, Prelude.Show, Prelude.Ord)

instance Aeson.ToJSON Experimental where
  toJSON Experimental = Aeson.object Prelude.mempty

instance Thrift.ThriftStruct Experimental where
  buildStruct _proxy Experimental = Thrift.genStruct _proxy []
  parseStruct _proxy
    = ST.runSTT
        (do Prelude.return ()
            let
              _parse _lastId
                = do _fieldBegin <- Trans.lift
                                      (Thrift.parseFieldBegin _proxy _lastId _idMap)
                     case _fieldBegin of
                       Thrift.FieldBegin _type _id _bool -> do case _id of
                                                                 _ -> Trans.lift
                                                                        (Thrift.parseSkip _proxy
                                                                           _type
                                                                           (Prelude.Just _bool))
                                                               _parse _id
                       Thrift.FieldEnd -> do Prelude.pure (Experimental)
              _idMap = HashMap.fromList []
            _parse 0)

instance DeepSeq.NFData Experimental where
  rnf Experimental = ()

instance Default.Default Experimental where
  def = Experimental

instance Hashable.Hashable Experimental where
  hashWithSalt __salt Experimental = __salt

data ReserveIds = ReserveIds{reserveIds_ids :: [Int.Int32],
                             reserveIds_id_ranges :: Map.Map Int.Int32 Int.Int32}
                  deriving (Prelude.Eq, Prelude.Show, Prelude.Ord)

instance Aeson.ToJSON ReserveIds where
  toJSON (ReserveIds __field__ids __field__id_ranges)
    = Aeson.object
        ("ids" .= __field__ids :
           "id_ranges" .= Map.mapKeys Thrift.keyToStr __field__id_ranges :
             Prelude.mempty)

instance Thrift.ThriftStruct ReserveIds where
  buildStruct _proxy (ReserveIds __field__ids __field__id_ranges)
    = Thrift.genStruct _proxy
        (Thrift.genField _proxy "ids" (Thrift.getListType _proxy) 1 0
           (Thrift.genListPrim _proxy (Thrift.getI32Type _proxy)
              (Thrift.genI32Prim _proxy)
              __field__ids)
           :
           Thrift.genField _proxy "id_ranges" (Thrift.getMapType _proxy) 2 1
             ((Thrift.genMapPrim _proxy (Thrift.getI32Type _proxy)
                 (Thrift.getI32Type _proxy)
                 Prelude.False
                 (Thrift.genI32Prim _proxy)
                 (Thrift.genI32Prim _proxy)
                 . Map.toList)
                __field__id_ranges)
             : [])
  parseStruct _proxy
    = ST.runSTT
        (do Prelude.return ()
            __field__ids <- ST.newSTRef Default.def
            __field__id_ranges <- ST.newSTRef Default.def
            let
              _parse _lastId
                = do _fieldBegin <- Trans.lift
                                      (Thrift.parseFieldBegin _proxy _lastId _idMap)
                     case _fieldBegin of
                       Thrift.FieldBegin _type _id _bool -> do case _id of
                                                                 1 | _type ==
                                                                       Thrift.getListType _proxy
                                                                     ->
                                                                     do !_val <- Trans.lift
                                                                                   (Prelude.snd <$>
                                                                                      Thrift.parseList
                                                                                        _proxy
                                                                                        (Thrift.parseI32
                                                                                           _proxy))
                                                                        ST.writeSTRef __field__ids
                                                                          _val
                                                                 2 | _type ==
                                                                       Thrift.getMapType _proxy
                                                                     ->
                                                                     do !_val <- Trans.lift
                                                                                   (Map.fromList <$>
                                                                                      Thrift.parseMap
                                                                                        _proxy
                                                                                        (Thrift.parseI32
                                                                                           _proxy)
                                                                                        (Thrift.parseI32
                                                                                           _proxy)
                                                                                        Prelude.False)
                                                                        ST.writeSTRef
                                                                          __field__id_ranges
                                                                          _val
                                                                 _ -> Trans.lift
                                                                        (Thrift.parseSkip _proxy
                                                                           _type
                                                                           (Prelude.Just _bool))
                                                               _parse _id
                       Thrift.FieldEnd -> do !__val__ids <- ST.readSTRef __field__ids
                                             !__val__id_ranges <- ST.readSTRef __field__id_ranges
                                             Prelude.pure (ReserveIds __val__ids __val__id_ranges)
              _idMap = HashMap.fromList [("ids", 1), ("id_ranges", 2)]
            _parse 0)

instance DeepSeq.NFData ReserveIds where
  rnf (ReserveIds __field__ids __field__id_ranges)
    = DeepSeq.rnf __field__ids `Prelude.seq`
        DeepSeq.rnf __field__id_ranges `Prelude.seq` ()

instance Default.Default ReserveIds where
  def = ReserveIds Default.def Default.def

instance Hashable.Hashable ReserveIds where
  hashWithSalt __salt (ReserveIds _ids _id_ranges)
    = Hashable.hashWithSalt (Hashable.hashWithSalt __salt _ids)
        ((Prelude.map (\ (_k, _v) -> (_k, _v)) . Map.toAscList) _id_ranges)

instance Thrift.HasField "ids" ReserveIds ([Int.Int32]) where
  getField = reserveIds_ids

instance Thrift.HasField "id_ranges" ReserveIds
           (Map.Map Int.Int32 Int.Int32)
         where
  getField = reserveIds_id_ranges

newtype RequiresBackwardCompatibility = RequiresBackwardCompatibility{requiresBackwardCompatibility_field_name
                                                                      :: Prelude.Bool}
                                        deriving (Prelude.Eq, Prelude.Show, Prelude.Ord)

instance Aeson.ToJSON RequiresBackwardCompatibility where
  toJSON (RequiresBackwardCompatibility __field__field_name)
    = Aeson.object
        ("field_name" .= __field__field_name : Prelude.mempty)

instance Thrift.ThriftStruct RequiresBackwardCompatibility where
  buildStruct _proxy
    (RequiresBackwardCompatibility __field__field_name)
    = Thrift.genStruct _proxy
        (Thrift.genFieldBool _proxy "field_name" 1 0 __field__field_name :
           [])
  parseStruct _proxy
    = ST.runSTT
        (do Prelude.return ()
            __field__field_name <- ST.newSTRef Prelude.False
            let
              _parse _lastId
                = do _fieldBegin <- Trans.lift
                                      (Thrift.parseFieldBegin _proxy _lastId _idMap)
                     case _fieldBegin of
                       Thrift.FieldBegin _type _id _bool -> do case _id of
                                                                 1 | _type ==
                                                                       Thrift.getBoolType _proxy
                                                                     ->
                                                                     do !_val <- Trans.lift
                                                                                   (Thrift.parseBoolF
                                                                                      _proxy
                                                                                      _bool)
                                                                        ST.writeSTRef
                                                                          __field__field_name
                                                                          _val
                                                                 _ -> Trans.lift
                                                                        (Thrift.parseSkip _proxy
                                                                           _type
                                                                           (Prelude.Just _bool))
                                                               _parse _id
                       Thrift.FieldEnd -> do !__val__field_name <- ST.readSTRef
                                                                     __field__field_name
                                             Prelude.pure
                                               (RequiresBackwardCompatibility __val__field_name)
              _idMap = HashMap.fromList [("field_name", 1)]
            _parse 0)

instance DeepSeq.NFData RequiresBackwardCompatibility where
  rnf (RequiresBackwardCompatibility __field__field_name)
    = DeepSeq.rnf __field__field_name `Prelude.seq` ()

instance Default.Default RequiresBackwardCompatibility where
  def = RequiresBackwardCompatibility Prelude.False

instance Hashable.Hashable RequiresBackwardCompatibility where
  hashWithSalt __salt (RequiresBackwardCompatibility _field_name)
    = Hashable.hashWithSalt __salt _field_name

instance Thrift.HasField "field_name" RequiresBackwardCompatibility
           (Prelude.Bool)
         where
  getField = requiresBackwardCompatibility_field_name

data TerseWrite = TerseWrite{}
                  deriving (Prelude.Eq, Prelude.Show, Prelude.Ord)

instance Aeson.ToJSON TerseWrite where
  toJSON TerseWrite = Aeson.object Prelude.mempty

instance Thrift.ThriftStruct TerseWrite where
  buildStruct _proxy TerseWrite = Thrift.genStruct _proxy []
  parseStruct _proxy
    = ST.runSTT
        (do Prelude.return ()
            let
              _parse _lastId
                = do _fieldBegin <- Trans.lift
                                      (Thrift.parseFieldBegin _proxy _lastId _idMap)
                     case _fieldBegin of
                       Thrift.FieldBegin _type _id _bool -> do case _id of
                                                                 _ -> Trans.lift
                                                                        (Thrift.parseSkip _proxy
                                                                           _type
                                                                           (Prelude.Just _bool))
                                                               _parse _id
                       Thrift.FieldEnd -> do Prelude.pure (TerseWrite)
              _idMap = HashMap.fromList []
            _parse 0)

instance DeepSeq.NFData TerseWrite where
  rnf TerseWrite = ()

instance Default.Default TerseWrite where
  def = TerseWrite

instance Hashable.Hashable TerseWrite where
  hashWithSalt __salt TerseWrite = __salt

data Box = Box{}
           deriving (Prelude.Eq, Prelude.Show, Prelude.Ord)

instance Aeson.ToJSON Box where
  toJSON Box = Aeson.object Prelude.mempty

instance Thrift.ThriftStruct Box where
  buildStruct _proxy Box = Thrift.genStruct _proxy []
  parseStruct _proxy
    = ST.runSTT
        (do Prelude.return ()
            let
              _parse _lastId
                = do _fieldBegin <- Trans.lift
                                      (Thrift.parseFieldBegin _proxy _lastId _idMap)
                     case _fieldBegin of
                       Thrift.FieldBegin _type _id _bool -> do case _id of
                                                                 _ -> Trans.lift
                                                                        (Thrift.parseSkip _proxy
                                                                           _type
                                                                           (Prelude.Just _bool))
                                                               _parse _id
                       Thrift.FieldEnd -> do Prelude.pure (Box)
              _idMap = HashMap.fromList []
            _parse 0)

instance DeepSeq.NFData Box where
  rnf Box = ()

instance Default.Default Box where
  def = Box

instance Hashable.Hashable Box where
  hashWithSalt __salt Box = __salt

data Mixin = Mixin{}
             deriving (Prelude.Eq, Prelude.Show, Prelude.Ord)

instance Aeson.ToJSON Mixin where
  toJSON Mixin = Aeson.object Prelude.mempty

instance Thrift.ThriftStruct Mixin where
  buildStruct _proxy Mixin = Thrift.genStruct _proxy []
  parseStruct _proxy
    = ST.runSTT
        (do Prelude.return ()
            let
              _parse _lastId
                = do _fieldBegin <- Trans.lift
                                      (Thrift.parseFieldBegin _proxy _lastId _idMap)
                     case _fieldBegin of
                       Thrift.FieldBegin _type _id _bool -> do case _id of
                                                                 _ -> Trans.lift
                                                                        (Thrift.parseSkip _proxy
                                                                           _type
                                                                           (Prelude.Just _bool))
                                                               _parse _id
                       Thrift.FieldEnd -> do Prelude.pure (Mixin)
              _idMap = HashMap.fromList []
            _parse 0)

instance DeepSeq.NFData Mixin where
  rnf Mixin = ()

instance Default.Default Mixin where
  def = Mixin

instance Hashable.Hashable Mixin where
  hashWithSalt __salt Mixin = __salt

data SerializeInFieldIdOrder = SerializeInFieldIdOrder{}
                               deriving (Prelude.Eq, Prelude.Show, Prelude.Ord)

instance Aeson.ToJSON SerializeInFieldIdOrder where
  toJSON SerializeInFieldIdOrder = Aeson.object Prelude.mempty

instance Thrift.ThriftStruct SerializeInFieldIdOrder where
  buildStruct _proxy SerializeInFieldIdOrder
    = Thrift.genStruct _proxy []
  parseStruct _proxy
    = ST.runSTT
        (do Prelude.return ()
            let
              _parse _lastId
                = do _fieldBegin <- Trans.lift
                                      (Thrift.parseFieldBegin _proxy _lastId _idMap)
                     case _fieldBegin of
                       Thrift.FieldBegin _type _id _bool -> do case _id of
                                                                 _ -> Trans.lift
                                                                        (Thrift.parseSkip _proxy
                                                                           _type
                                                                           (Prelude.Just _bool))
                                                               _parse _id
                       Thrift.FieldEnd -> do Prelude.pure (SerializeInFieldIdOrder)
              _idMap = HashMap.fromList []
            _parse 0)

instance DeepSeq.NFData SerializeInFieldIdOrder where
  rnf SerializeInFieldIdOrder = ()

instance Default.Default SerializeInFieldIdOrder where
  def = SerializeInFieldIdOrder

instance Hashable.Hashable SerializeInFieldIdOrder where
  hashWithSalt __salt SerializeInFieldIdOrder = __salt

data BitmaskEnum = BitmaskEnum{}
                   deriving (Prelude.Eq, Prelude.Show, Prelude.Ord)

instance Aeson.ToJSON BitmaskEnum where
  toJSON BitmaskEnum = Aeson.object Prelude.mempty

instance Thrift.ThriftStruct BitmaskEnum where
  buildStruct _proxy BitmaskEnum = Thrift.genStruct _proxy []
  parseStruct _proxy
    = ST.runSTT
        (do Prelude.return ()
            let
              _parse _lastId
                = do _fieldBegin <- Trans.lift
                                      (Thrift.parseFieldBegin _proxy _lastId _idMap)
                     case _fieldBegin of
                       Thrift.FieldBegin _type _id _bool -> do case _id of
                                                                 _ -> Trans.lift
                                                                        (Thrift.parseSkip _proxy
                                                                           _type
                                                                           (Prelude.Just _bool))
                                                               _parse _id
                       Thrift.FieldEnd -> do Prelude.pure (BitmaskEnum)
              _idMap = HashMap.fromList []
            _parse 0)

instance DeepSeq.NFData BitmaskEnum where
  rnf BitmaskEnum = ()

instance Default.Default BitmaskEnum where
  def = BitmaskEnum

instance Hashable.Hashable BitmaskEnum where
  hashWithSalt __salt BitmaskEnum = __salt

data ExceptionMessage = ExceptionMessage{}
                        deriving (Prelude.Eq, Prelude.Show, Prelude.Ord)

instance Aeson.ToJSON ExceptionMessage where
  toJSON ExceptionMessage = Aeson.object Prelude.mempty

instance Thrift.ThriftStruct ExceptionMessage where
  buildStruct _proxy ExceptionMessage = Thrift.genStruct _proxy []
  parseStruct _proxy
    = ST.runSTT
        (do Prelude.return ()
            let
              _parse _lastId
                = do _fieldBegin <- Trans.lift
                                      (Thrift.parseFieldBegin _proxy _lastId _idMap)
                     case _fieldBegin of
                       Thrift.FieldBegin _type _id _bool -> do case _id of
                                                                 _ -> Trans.lift
                                                                        (Thrift.parseSkip _proxy
                                                                           _type
                                                                           (Prelude.Just _bool))
                                                               _parse _id
                       Thrift.FieldEnd -> do Prelude.pure (ExceptionMessage)
              _idMap = HashMap.fromList []
            _parse 0)

instance DeepSeq.NFData ExceptionMessage where
  rnf ExceptionMessage = ()

instance Default.Default ExceptionMessage where
  def = ExceptionMessage

instance Hashable.Hashable ExceptionMessage where
  hashWithSalt __salt ExceptionMessage = __salt

newtype GenerateRuntimeSchema = GenerateRuntimeSchema{generateRuntimeSchema_name
                                                      :: Text.Text}
                                deriving (Prelude.Eq, Prelude.Show, Prelude.Ord)

instance Aeson.ToJSON GenerateRuntimeSchema where
  toJSON (GenerateRuntimeSchema __field__name)
    = Aeson.object ("name" .= __field__name : Prelude.mempty)

instance Thrift.ThriftStruct GenerateRuntimeSchema where
  buildStruct _proxy (GenerateRuntimeSchema __field__name)
    = Thrift.genStruct _proxy
        (Thrift.genField _proxy "name" (Thrift.getStringType _proxy) 1 0
           (Thrift.genText _proxy __field__name)
           : [])
  parseStruct _proxy
    = ST.runSTT
        (do Prelude.return ()
            __field__name <- ST.newSTRef ""
            let
              _parse _lastId
                = do _fieldBegin <- Trans.lift
                                      (Thrift.parseFieldBegin _proxy _lastId _idMap)
                     case _fieldBegin of
                       Thrift.FieldBegin _type _id _bool -> do case _id of
                                                                 1 | _type ==
                                                                       Thrift.getStringType _proxy
                                                                     ->
                                                                     do !_val <- Trans.lift
                                                                                   (Thrift.parseText
                                                                                      _proxy)
                                                                        ST.writeSTRef __field__name
                                                                          _val
                                                                 _ -> Trans.lift
                                                                        (Thrift.parseSkip _proxy
                                                                           _type
                                                                           (Prelude.Just _bool))
                                                               _parse _id
                       Thrift.FieldEnd -> do !__val__name <- ST.readSTRef __field__name
                                             Prelude.pure (GenerateRuntimeSchema __val__name)
              _idMap = HashMap.fromList [("name", 1)]
            _parse 0)

instance DeepSeq.NFData GenerateRuntimeSchema where
  rnf (GenerateRuntimeSchema __field__name)
    = DeepSeq.rnf __field__name `Prelude.seq` ()

instance Default.Default GenerateRuntimeSchema where
  def = GenerateRuntimeSchema ""

instance Hashable.Hashable GenerateRuntimeSchema where
  hashWithSalt __salt (GenerateRuntimeSchema _name)
    = Hashable.hashWithSalt __salt _name

instance Thrift.HasField "name" GenerateRuntimeSchema (Text.Text)
         where
  getField = generateRuntimeSchema_name

data InternBox = InternBox{}
                 deriving (Prelude.Eq, Prelude.Show, Prelude.Ord)

instance Aeson.ToJSON InternBox where
  toJSON InternBox = Aeson.object Prelude.mempty

instance Thrift.ThriftStruct InternBox where
  buildStruct _proxy InternBox = Thrift.genStruct _proxy []
  parseStruct _proxy
    = ST.runSTT
        (do Prelude.return ()
            let
              _parse _lastId
                = do _fieldBegin <- Trans.lift
                                      (Thrift.parseFieldBegin _proxy _lastId _idMap)
                     case _fieldBegin of
                       Thrift.FieldBegin _type _id _bool -> do case _id of
                                                                 _ -> Trans.lift
                                                                        (Thrift.parseSkip _proxy
                                                                           _type
                                                                           (Prelude.Just _bool))
                                                               _parse _id
                       Thrift.FieldEnd -> do Prelude.pure (InternBox)
              _idMap = HashMap.fromList []
            _parse 0)

instance DeepSeq.NFData InternBox where
  rnf InternBox = ()

instance Default.Default InternBox where
  def = InternBox

instance Hashable.Hashable InternBox where
  hashWithSalt __salt InternBox = __salt

data Serial = Serial{}
              deriving (Prelude.Eq, Prelude.Show, Prelude.Ord)

instance Aeson.ToJSON Serial where
  toJSON Serial = Aeson.object Prelude.mempty

instance Thrift.ThriftStruct Serial where
  buildStruct _proxy Serial = Thrift.genStruct _proxy []
  parseStruct _proxy
    = ST.runSTT
        (do Prelude.return ()
            let
              _parse _lastId
                = do _fieldBegin <- Trans.lift
                                      (Thrift.parseFieldBegin _proxy _lastId _idMap)
                     case _fieldBegin of
                       Thrift.FieldBegin _type _id _bool -> do case _id of
                                                                 _ -> Trans.lift
                                                                        (Thrift.parseSkip _proxy
                                                                           _type
                                                                           (Prelude.Just _bool))
                                                               _parse _id
                       Thrift.FieldEnd -> do Prelude.pure (Serial)
              _idMap = HashMap.fromList []
            _parse 0)

instance DeepSeq.NFData Serial where
  rnf Serial = ()

instance Default.Default Serial where
  def = Serial

instance Hashable.Hashable Serial where
  hashWithSalt __salt Serial = __salt

newtype Uri = Uri{uri_value :: Text.Text}
              deriving (Prelude.Eq, Prelude.Show, Prelude.Ord)

instance Aeson.ToJSON Uri where
  toJSON (Uri __field__value)
    = Aeson.object ("value" .= __field__value : Prelude.mempty)

instance Thrift.ThriftStruct Uri where
  buildStruct _proxy (Uri __field__value)
    = Thrift.genStruct _proxy
        (Thrift.genField _proxy "value" (Thrift.getStringType _proxy) 1 0
           (Thrift.genText _proxy __field__value)
           : [])
  parseStruct _proxy
    = ST.runSTT
        (do Prelude.return ()
            __field__value <- ST.newSTRef ""
            let
              _parse _lastId
                = do _fieldBegin <- Trans.lift
                                      (Thrift.parseFieldBegin _proxy _lastId _idMap)
                     case _fieldBegin of
                       Thrift.FieldBegin _type _id _bool -> do case _id of
                                                                 1 | _type ==
                                                                       Thrift.getStringType _proxy
                                                                     ->
                                                                     do !_val <- Trans.lift
                                                                                   (Thrift.parseText
                                                                                      _proxy)
                                                                        ST.writeSTRef __field__value
                                                                          _val
                                                                 _ -> Trans.lift
                                                                        (Thrift.parseSkip _proxy
                                                                           _type
                                                                           (Prelude.Just _bool))
                                                               _parse _id
                       Thrift.FieldEnd -> do !__val__value <- ST.readSTRef __field__value
                                             Prelude.pure (Uri __val__value)
              _idMap = HashMap.fromList [("value", 1)]
            _parse 0)

instance DeepSeq.NFData Uri where
  rnf (Uri __field__value)
    = DeepSeq.rnf __field__value `Prelude.seq` ()

instance Default.Default Uri where
  def = Uri ""

instance Hashable.Hashable Uri where
  hashWithSalt __salt (Uri _value)
    = Hashable.hashWithSalt __salt _value

instance Thrift.HasField "value" Uri (Text.Text) where
  getField = uri_value

newtype Priority = Priority{priority_level :: RpcPriority}
                   deriving (Prelude.Eq, Prelude.Show, Prelude.Ord)

instance Aeson.ToJSON Priority where
  toJSON (Priority __field__level)
    = Aeson.object ("level" .= __field__level : Prelude.mempty)

instance Thrift.ThriftStruct Priority where
  buildStruct _proxy (Priority __field__level)
    = Thrift.genStruct _proxy
        (Thrift.genField _proxy "level" (Thrift.getI32Type _proxy) 1 0
           ((Thrift.genI32 _proxy . Prelude.fromIntegral .
               Thrift.fromThriftEnum)
              __field__level)
           : [])
  parseStruct _proxy
    = ST.runSTT
        (do Prelude.return ()
            __field__level <- ST.newSTRef Default.def
            let
              _parse _lastId
                = do _fieldBegin <- Trans.lift
                                      (Thrift.parseFieldBegin _proxy _lastId _idMap)
                     case _fieldBegin of
                       Thrift.FieldBegin _type _id _bool -> do case _id of
                                                                 1 | _type ==
                                                                       Thrift.getI32Type _proxy
                                                                     ->
                                                                     do !_val <- Trans.lift
                                                                                   (Thrift.parseEnum
                                                                                      _proxy
                                                                                      "RpcPriority")
                                                                        ST.writeSTRef __field__level
                                                                          _val
                                                                 _ -> Trans.lift
                                                                        (Thrift.parseSkip _proxy
                                                                           _type
                                                                           (Prelude.Just _bool))
                                                               _parse _id
                       Thrift.FieldEnd -> do !__val__level <- ST.readSTRef __field__level
                                             Prelude.pure (Priority __val__level)
              _idMap = HashMap.fromList [("level", 1)]
            _parse 0)

instance DeepSeq.NFData Priority where
  rnf (Priority __field__level)
    = DeepSeq.rnf __field__level `Prelude.seq` ()

instance Default.Default Priority where
  def = Priority Default.def

instance Hashable.Hashable Priority where
  hashWithSalt __salt (Priority _level)
    = Hashable.hashWithSalt __salt _level

instance Thrift.HasField "level" Priority (RpcPriority) where
  getField = priority_level

data RpcPriority = RpcPriority_HIGH_IMPORTANT
                 | RpcPriority_HIGH
                 | RpcPriority_IMPORTANT
                 | RpcPriority_NORMAL
                 | RpcPriority_BEST_EFFORT
                 | RpcPriority__UNKNOWN Prelude.Int
                   deriving (Prelude.Eq, Prelude.Show, Prelude.Ord)

instance Aeson.ToJSON RpcPriority where
  toJSON = Aeson.toJSON . Thrift.fromThriftEnum

instance DeepSeq.NFData RpcPriority where
  rnf __RpcPriority = Prelude.seq __RpcPriority ()

instance Default.Default RpcPriority where
  def = RpcPriority_HIGH_IMPORTANT

instance Hashable.Hashable RpcPriority where
  hashWithSalt _salt _val
    = Hashable.hashWithSalt _salt (Thrift.fromThriftEnum _val)

instance Thrift.ThriftEnum RpcPriority where
  toThriftEnum 0 = RpcPriority_HIGH_IMPORTANT
  toThriftEnum 1 = RpcPriority_HIGH
  toThriftEnum 2 = RpcPriority_IMPORTANT
  toThriftEnum 3 = RpcPriority_NORMAL
  toThriftEnum 4 = RpcPriority_BEST_EFFORT
  toThriftEnum val = RpcPriority__UNKNOWN val
  fromThriftEnum RpcPriority_HIGH_IMPORTANT = 0
  fromThriftEnum RpcPriority_HIGH = 1
  fromThriftEnum RpcPriority_IMPORTANT = 2
  fromThriftEnum RpcPriority_NORMAL = 3
  fromThriftEnum RpcPriority_BEST_EFFORT = 4
  fromThriftEnum (RpcPriority__UNKNOWN val) = val
  allThriftEnumValues
    = [RpcPriority_HIGH_IMPORTANT, RpcPriority_HIGH,
       RpcPriority_IMPORTANT, RpcPriority_NORMAL, RpcPriority_BEST_EFFORT]
  toThriftEnumEither 0 = Prelude.Right RpcPriority_HIGH_IMPORTANT
  toThriftEnumEither 1 = Prelude.Right RpcPriority_HIGH
  toThriftEnumEither 2 = Prelude.Right RpcPriority_IMPORTANT
  toThriftEnumEither 3 = Prelude.Right RpcPriority_NORMAL
  toThriftEnumEither 4 = Prelude.Right RpcPriority_BEST_EFFORT
  toThriftEnumEither val
    = Prelude.Left
        ("toThriftEnumEither: not a valid identifier for enum RpcPriority: "
           ++ Prelude.show val)

newtype DeprecatedUnvalidatedAnnotations = DeprecatedUnvalidatedAnnotations{deprecatedUnvalidatedAnnotations_items
                                                                            ::
                                                                            Map.Map Text.Text
                                                                              Text.Text}
                                           deriving (Prelude.Eq, Prelude.Show, Prelude.Ord)

instance Aeson.ToJSON DeprecatedUnvalidatedAnnotations where
  toJSON (DeprecatedUnvalidatedAnnotations __field__items)
    = Aeson.object ("items" .= __field__items : Prelude.mempty)

instance Thrift.ThriftStruct DeprecatedUnvalidatedAnnotations where
  buildStruct _proxy
    (DeprecatedUnvalidatedAnnotations __field__items)
    = Thrift.genStruct _proxy
        (Thrift.genField _proxy "items" (Thrift.getMapType _proxy) 1 0
           ((Thrift.genMap _proxy (Thrift.getStringType _proxy)
               (Thrift.getStringType _proxy)
               Prelude.True
               (Thrift.genText _proxy)
               (Thrift.genText _proxy)
               . Map.toList)
              __field__items)
           : [])
  parseStruct _proxy
    = ST.runSTT
        (do Prelude.return ()
            __field__items <- ST.newSTRef Default.def
            let
              _parse _lastId
                = do _fieldBegin <- Trans.lift
                                      (Thrift.parseFieldBegin _proxy _lastId _idMap)
                     case _fieldBegin of
                       Thrift.FieldBegin _type _id _bool -> do case _id of
                                                                 1 | _type ==
                                                                       Thrift.getMapType _proxy
                                                                     ->
                                                                     do !_val <- Trans.lift
                                                                                   (Map.fromList <$>
                                                                                      Thrift.parseMap
                                                                                        _proxy
                                                                                        (Thrift.parseText
                                                                                           _proxy)
                                                                                        (Thrift.parseText
                                                                                           _proxy)
                                                                                        Prelude.True)
                                                                        ST.writeSTRef __field__items
                                                                          _val
                                                                 _ -> Trans.lift
                                                                        (Thrift.parseSkip _proxy
                                                                           _type
                                                                           (Prelude.Just _bool))
                                                               _parse _id
                       Thrift.FieldEnd -> do !__val__items <- ST.readSTRef __field__items
                                             Prelude.pure
                                               (DeprecatedUnvalidatedAnnotations __val__items)
              _idMap = HashMap.fromList [("items", 1)]
            _parse 0)

instance DeepSeq.NFData DeprecatedUnvalidatedAnnotations where
  rnf (DeprecatedUnvalidatedAnnotations __field__items)
    = DeepSeq.rnf __field__items `Prelude.seq` ()

instance Default.Default DeprecatedUnvalidatedAnnotations where
  def = DeprecatedUnvalidatedAnnotations Default.def

instance Hashable.Hashable DeprecatedUnvalidatedAnnotations where
  hashWithSalt __salt (DeprecatedUnvalidatedAnnotations _items)
    = Hashable.hashWithSalt __salt
        ((Prelude.map (\ (_k, _v) -> (_k, _v)) . Map.toAscList) _items)

instance Thrift.HasField "items" DeprecatedUnvalidatedAnnotations
           (Map.Map Text.Text Text.Text)
         where
  getField = deprecatedUnvalidatedAnnotations_items